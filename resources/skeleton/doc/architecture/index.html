<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <title>JSesh Architecture</title>
  </head>

  <body>
    <h1>JSesh Architecture</h1>

    <h2>A Global Approach</h2>

    <h2>The Parsing System</h2>

    <h2>View Creation</h2>

    <h2>Actual Drawing</h2>
    
    <h2>View update</h2>

    <h2>Speeding up JSesh : caching</h2>

    Back in 1994, when I started writing tksesh, my computer had a
    486SX25 processor (recent machines now have a processor which goes
    roughly 100 times as fast!). On such slow machines, a brute-force
    approach to draw hieroglyphs could take a few seconds for a page,
    which was too slow for interactive use. I really wanted my
    hieroglyphs to display quickly, specially when editing the text. A
    complete redrawing of a text page takes some time, mostly because
    vector graphics involve some computation. By comparison, copying
    bitmaps is <em>very</em> fast. So I designed a caching system for
    tksesh, the idea being basically that when redrawing a window, it
    kept the bitmap of the previous state of the window, and copied
    from it as many groups of hieroglyphs as possible, redrawing only
    the new groups or the modified ones.

    <p> Now, when I wrote JSesh, I decided to follow the computing
    proverb <em>first make it work, then make it fast.</em> JSesh
    architecture is meant to be clean, with a complete separation
    between the data (TopItemList) and its view (MDCView). In
    particular, I wanted to use the same code for display, regardless
    of the target. So I did not implement caching at first. When the
    code was functionnal, it became evident that, in practice, the
    actual drawing of the groups was a real bootleneck (much more, for
    instance, than the fact that redrawing is done in O(n) time, where
    n is the whole text size !).</p>
      
    <p> So I decided to implement a caching system. One of its
    problems was that in-memory images take a lot of memory. Tksesh
    used monochrome bitmaps, and so needed 24 times less memory. But
    we now use antialiasing and colors. <em>In fine,</em> the cleaner
    architecture of JSesh provided a solution. </p>

    <p>The optional cache is a table that associate a manuel de codage
      group with its image. The cache has a limited size, so new
      groups will take the place of old ones. Another decision is that
      all cached images have the same dimensions. It allows us to
      re-use old bitmaps for new groups. In the case a group requires
      a larger bitmap, it won't be cached. The system gives good
      results because such groups are few in number. A bitmap is
      shared between all groups that have the same manuel de codage
      representation (plus the same "state" : shaded, red...). This
      makes a huge difference in efficiency. The caching system of
      tksesh sped up the <em>redrawing</em> of a text ; this caching
      system speeps up the actual <em>drawing</em> of a page, because
      statistically, groups tend to be repeated. 
      
      Here is the way caching is used in the code :
      <span class="code">
      </span>
      

    <hr>
    <address><a href="mailto:rosmord@iut.univ-paris8.fr">ROSMORDUC Serge</a></address>
<!-- Created: Sat Oct 30 11:09:14 CEST 2004 -->
<!-- hhmts start -->
Last modified: Sat Oct 30 11:51:17 CEST 2004
<!-- hhmts end -->
  </body>
</html>
